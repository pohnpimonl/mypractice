import java.util.HashMap;
import java.util.Map;

public class CheckIfArrayPairsAreDivisibleByK1497 {
    public static boolean canArrange(int[] arr, int k) {
        /* จากข้อกำหนดที่ให้มา:
         * - ขนาดของอาร์เรย์ arr.length == n ซึ่ง 1 <= n <= 10^5
         * - n เป็นจำนวนคู่เสมอ
         * - ค่าในอาร์เรย์มีช่วง -10^9 <= arr[i] <= 10^9
         * - ค่า k มีช่วง 1 <= k <= 10^5
         * 
         * ทำให้เราต้องออกแบบโค้ดให้มี ประสิทธิภาพสูง เพื่อรองรับการทำงานที่ข้อมูลจำนวนมากได้อย่างรวดเร็ว โดย
         * การหาคู่ที่ผลบวกหารด้วย k ลงตัวนั้น สามารถทำได้โดยการใช้เทคนิคการนับโมดูลัส (modulo counting)
         * แทนการใช้ลูปซ้อน (nested loop) ที่มีความซับซ้อน O(n^2) ซึ่งจะทำงานช้าเกินไปเมื่อ n มีค่ามาก
         * 
         * แนวคิดการแก้ปัญหาด้วยการนับโมดูลัส:
         * - แทนที่จะจับคู่ตัวเลขแบบลูปซ้อน เราจะใช้การนับจำนวนของตัวเลขที่เหลือเศษต่าง ๆ จากการหารด้วย k
         * โดยสำหรับตัวเลข a ที่มีเศษเหลือ r1 เมื่อหารด้วย k เราจะหาค่า b ที่มีเศษเหลือ r2 โดยที่ผลรวม
         * r1 + r2 หารด้วย k ลงตัว
         * - ซึ่งหมายความว่า r1 + r2 = k หรือในกรณีที่ r1 == 0 หรือ r1 == r2 ต้องมาคู่กันเอง
         */
        boolean check = false;
        Map<Integer, Integer> remainderCount = new HashMap<>();

        // นับจำนวนของเศษที่ได้จากการหารด้วย k
        for (int num : arr) {
            int remainder = ((num % k) + k) % k;  // เพื่อจัดการกับค่าลบ
            remainderCount.put(remainder, remainderCount.getOrDefault(remainder, 0) + 1);
        }

        int count = 0;

        // ตรวจสอบแต่ละเศษที่เหลือ
        for (int i = 0; i <= k / 2; i++) {
            if (i == 0 || i == k - i) {
                // เศษ 0 หรือ (k / 2) จะต้องมาคู่กันเอง
                int pairs = remainderCount.getOrDefault(i, 0) / 2;
                count += pairs;
            } else {
                // เศษ r1 กับเศษ k - r1 จะมาคู่กัน
                int r1 = remainderCount.getOrDefault(i, 0);
                int r2 = remainderCount.getOrDefault(k - i, 0);
                count += Math.min(r1, r2);
            }
        }

        if (count == (arr.length/2)) {
            System.out.println("count : " + count);
            System.out.println("arr.length/2 : " + arr.length/2);
            check = true;
        }
        return check;
        /* อธิบายโค้ด:
         * 1. การคำนวณโมดูลัส (remainder):
         * - คำนวณเศษที่ได้จากการหารด้วย k และเก็บจำนวนของแต่ละเศษในแผนที่ (remainderCount) โดย
         * ใช้ Map<Integer, Integer> เพื่อเก็บว่ามีตัวเลขที่เหลือเศษเท่าไรจากการหารด้วย k
         * - ใช้ (num % k + k) % k เพื่อจัดการกับกรณีที่ตัวเลขมีค่าลบ (ทำให้เศษเป็นบวกเสมอ)
         * 2. การหาคู่:
         * - สำหรับเศษ 0 และเศษ k/2 (ในกรณี k เป็นเลขคู่) จะต้องมาคู่กันเอง ดังนั้นจำนวนนับต้องหารด้วย 2
         * - สำหรับเศษ r1 และ k - r1 เราจะหาค่าที่ต่ำสุดระหว่างจำนวนนับของทั้งสองเศษนั้นและบวกเข้ากับ
         * ผลรวมของคู่
         * 3. ผลลัพธ์:
         * - เมื่อวนลูปหาคู่ครบแล้ว ผลลัพธ์สุดท้ายจะเป็นจำนวนคู่ที่ผลบวกหารด้วย k ลงตัว
         * 
         * ความซับซ้อนของอัลกอริทึม:
         * - การคำนวณโมดูลัสและนับจำนวนเศษใช้เวลาทั้งหมด O(n)
         * - การวนลูปตรวจสอบคู่ในโมดูลัสใช้เวลาทั้งหมด O(k) ดังนั้นความซับซ้อนทั้งหมดของอัลกอริทึมคือ O(n +
         * k) ซึ่งเพียงพอสำหรับ n และ k ในช่วงที่ให้มาคือสูงสุด 10^5
         */
    }
}


